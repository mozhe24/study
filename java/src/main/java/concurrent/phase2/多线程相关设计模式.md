# 多线程相关设计模式

## 单例设计模式

```java
package concurrent.phase2;

public class Singleton1 {
    
    private static final Singleton1 instance = new Singleton1();

    private Singleton1() {
        //empty
    }

    public static Singleton1 getInstance() {
        return instance;
    }
}
```

这是最简单的一种单例模式，在多线程情况下也是没问题的，但是就是这个类在加载的时候单例实例已经存在，可能我一时半会还不会用到，所以就想有一种懒加载的方式，当我用的时候再创建出来。

```java
package concurrent.phase2;

public class Singleton2 {

    private static Singleton2 instance;

    private Singleton2() {
        //empty
    }

    public static Singleton2 getInstance() {
        if (instance == null) {
            instance = new Singleton2();
        }
        return instance;
    }
}
```

这是最基本的懒加载方式，但是在多线程情况下会有问题，就是多个线程同时调用方法判断的时候拿到的实例都是空的，此时就会创建多个实例。那如果在**方法上加一个同步**可不可以呢？这是可以的，但是每次调用这个方法都需要去获取锁，这就变成了串行化了，会影响效率。于是我们使用双检查的方式

```java
package concurrent.phase2;

public class Singleton3 {

    private static Singleton3 instance;

    private Singleton3() {
        //empty
    }

    public static Singleton3 getInstance() {
        if (instance == null) {
            synchronized (Singleton3.class) {
                if (instance == null) {
                    instance = new Singleton3();
                }
            }
        }
        return instance;
    }
}
```

但是这里还是有一个问题，就是可能在实例化此对象的时候，其中引用了很多其他对象数据等等，需要一定时间才能做完，但是此时第一个线程已经返回了，第二个线程发现实例不为空就去用的时候，其实例引用的其他对象还没有真正的实例化完毕，此时就会导致空指针异常。这里涉及到重排序等优化。此时我们只需要使用`volatile`即可，此修饰表示不要给我做一些优化，实例返回了就表示实例化已经真正的完成了。

```java
package concurrent.phase2;

public class Singleton4 {

    private static volatile Singleton4 instance;

    private Singleton4() {
        //empty
    }

    public static Singleton4 getInstance() {
        if (instance == null) {
            synchronized (Singleton4.class) {
                if (instance == null) {
                    instance = new Singleton4();
                }
            }
        }
        return instance;
    }
}
```

下面看一种更优雅的方式

```java
package concurrent.phase2;

public class Singleton5 {

    private Singleton5() {
        //empty
    }

    private static class InstanceHolder{
        private final static Singleton5 instance = new Singleton5();
    }

    public static Singleton5 getInstance() {
        return InstanceHolder.instance;
    }
}
```

这里也是一种懒加载的方式，但是我们知道类加载的顺序是：**加载->链接（验证+准备+解析）->初始化（使用前的准备）->使用->卸载**。`InstanceHolder`一开始相当于定义了一个类，在只是解析了一下，只有当真正调用的时候才会对其进行初始化。还有一种方式就是枚举，枚举类构造函数是私有的，同时其中定义的类都是`final`的。

```java
package concurrent.phase2;

public class Singleton6 {

    private Singleton6() {
        //empty
    }

    public static Singleton6 getInstance() {
        return Singleton.INTANCE.getInstance();
    }

    private enum Singleton {
        INTANCE;

        private final Singleton6 instance;

        Singleton() {
            instance = new Singleton6();
        }

        public Singleton6 getInstance() {
            return instance;
        }
    }
}
```



## WaitSet

这个`wait set` 集合就是当线程中调用`wait`方法后，会将当前线程加入到该集合中，等待此线程被唤醒重新抢锁执行。这里主要要注意的一点是下面的第四点，调用`wait`的时候会记住此刻程序执行到的地址，便于下次接着执行。

```java
package concurrent.phase2;

import java.util.stream.IntStream;

/**
 * 1、所有的对象都有一个wait set， 用来存放该对象 wait 方法之后进入 blocked 状态线程;
 * 2、线程被 notify 之后不一定会立即执行;
 * 3、线程被从 wait set 中唤醒的顺序不一定按照启动的顺序;
 * 4、当wait之后被唤醒时，虽然是需要重新获取锁，但是这里是接着上次被wait的地方执行，而不是重新来过，这样就死循环类
 */
public class WaitSet {

    private static final Object LOCK = new Object();

    public static void main(String[] args) {
        IntStream.rangeClosed(1, 10).forEach(i ->
            new Thread(String.valueOf(i)) {
                @Override
                public void run() {
                    synchronized (LOCK) {
                        try {
                            System.out.println(Thread.currentThread().getName() + " into wait ");
                            LOCK.wait();
                            System.out.println(Thread.currentThread().getName() + " out wait ");
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }.start());
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        IntStream.rangeClosed(1, 10).forEach(i -> {
                synchronized (LOCK) {
                    //一个一个唤醒
                    LOCK.notify();
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        );

    }
}
```



## volatile

先看一个简单的例子

```java
package concurrent.phase2;

public class Volatile1 {

    private volatile static int INIT_VAL = 0;

    private final static int MAX_LIMIT = 5;

    public static void main(String[] args) {
        new Thread(() -> {
            int localVal = INIT_VAL;
            while (localVal < MAX_LIMIT) {
                if (localVal != INIT_VAL) {
                    System.out.printf("reader: The value updated to [%d]\n", INIT_VAL);
                    localVal = INIT_VAL;
                }
            }
        }, "reader").start();

        new Thread(() -> {
            int localVal = INIT_VAL;
            while (INIT_VAL < MAX_LIMIT) {
                System.out.printf("writer: Updated the value  to [%d]\n", ++localVal);
                INIT_VAL = localVal;
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "writer").start();

    }
}
```

这里起了两个线程，第一个线程读取，第二个线程修改，可以发现我们通过`volatile`就可以让第一个线程感知到相关变量值的变化。如果我们将`volatile`去掉的话变量的修改被别的线程是无法感知的。同时我们发现线程1始终无法感知变量的变化。

`JAVA`内存模型一般是有一个主内存，然后比如这里有两个`CPU`，`CPU1`和`CPU2`，各自有自己的`Cache`， `Cache1`和`Cache2`。那难道线程1只是从主内存中读取了一次变量值，然后放在`Cache1`之后就一直使用`Cache1`中的变量值？下面实验下

```java
package concurrent.phase2;

public class Volatile2 {

    private static int INIT_VAL = 0;

    private final static int MAX_LIMIT = 50;

    public static void main(String[] args) {
        new Thread(() -> {
            while (INIT_VAL < MAX_LIMIT) {
                System.out.println("T1 -> " + (++INIT_VAL));
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "ADDER-1").start();

        new Thread(() -> {
            while (INIT_VAL < MAX_LIMIT) {
                System.out.println("T2 -> " + (++INIT_VAL));
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "ADDER-2").start();

    }
}
```

这里我们发现在运行的过程中线程1中途也还是会从主内存中取值的，并且将自己的值更新到了主内存，那前面一个例子中（去掉`volatile`）为什么线程1却始终感知不到变量的变化呢？这里是因为去掉`volatile`，不仅变量变化无法感知，同时在线程1中`JVM`做了优化，`JVM`发现线程1中只有读操作，于是认定这个变量不会发生变化，于是就只会从`Cache1`中获取值。而后面的例子中两个线程都有写操作。同时对于上面的例子就算我们将`INIT_VAL`使用`volatile`修饰，会发现两个线程读取到的值也会冲突，这是因为volatile并不能保证原子性。`volatile`的主要两个特性就是有序性和可见性。



### 内存模型

先看一个例子，就是程序在执行下面这段代码的时候发生的事情

```java
i = 1;
i++;
```

这里如果有两个线程或者两个`CPU`执行，发生的事情如下

```java
CPU1: main memory -> i=1 -> Cache1(i=1) -> Cache1(i+1) -> Cache1(i=2) -> main Memory(i=2)
CPU2: main memory -> i=1 -> Cache2(i=1) -> Cache2(i+1) -> Cache2(i=2) -> main Memory(i=2)
```

这里的意思就是大家从主内存中获取到的`i`的值都为1，虽然最后加了两次，但是最终值却还是为2，而不是3。解决此问题有几种方式：

1、给数据总线枷锁（总线：数据总线、地址总线、控制总线）

2、`CPU`高速缓存一致性协议（`MESI`），这可以保证`Cache`和主线程中同一个变量的值是相同的。其主要思想就是当`CPU`写入数据的时候，如果发现该变量被共享，会发出一个信号，通知其他线程缓存无效。然后其他线程重新从主内存中获取。



对于`JMM`（`java`内存模型）是为了屏蔽相关CPU不同导致的问题，一般来说定义的本地变量数据放在栈（线程共享）中，而每个线程都会有自己的本地内存（线程独享）。



### 三个概念

1、原子性

就是对某个变量的多个操作，要么都成功，要么都失败。

`JMM`：对基本数据类型的变量读写保证了原子性。这些操作不可能被中断。

```java
// 这里的操作是不可能被中断的
i = 10
cache(i=10) -> main memory(i=10)
    
a = 10;//满足原子性
b = a;//不满足（a = 10,  -> b = a）
c++;//不满足(c = 0 -> c + 1 -> c = 2)
```

这里对于`long`和`double`类型的，如果在`32`位机器上执行，由于高低位的原因，不能保证原子性。



2、可见性

某个线程对某个变量值的改变，另外线程能够感知

`JMM`：`volatile`



3、有序性

就是保证程序执行的顺序，如下一段代码

```java
boolean flag = false;
int i = 1;
flag = true;
i++;
```

单线程中，`CPU`只要保证最终结果一致即可，可能对`flag`值的修改在定义变量`i`之前（**重排序**），但是这不影响两个变量最终的值，因为这两个变量是无关的，但是这两个变量可能在其他线程是有关的，其他线程需要程序按照定义的顺序执行，此时就可以使用`volatile`来保证。

`JMM`：保证了一部分有序性（`happens-before`原则），这是使用**内存屏障**来实现的。

* 一个线程内对变量的操作是有序的

  ```java
  //这里第一步肯定是在第三步之前的
  int a;
  int b;
  a = 1;
  ```

* 解锁必须发生在加锁之后

* `volatile`修饰的变量，对于一个变量的写操作必须发生在读操作之前

* 传递规则：操作一个变量`A`先于`B`，`B`先于`C`，那么`A`肯定先于`C`被操作。

* 线程启动规则：线程的`start`方法先于`run`方法。

* 线程的中断规则：中断操作必须发生在捕获异常之前

* 对象的销毁规则：对象的初始化必须发生在`finalize`之前



`volatile`只保证有序性和可见性

1、保证重排序不会把后面的指令放到屏障前面，也不会把前面的指令发到屏障后面

2、强制对缓存的修改操作立即写入到主内存

3、如果是写操作，导致其他`CPU`中的缓存失效。



### 使用场景

1、状态量标记

2、屏障前后顺序一致



## 观察者（监听者）设计模式

当我们需要知道某个程序的执行步骤的时候有几种方式，一种就是不断的循环取值，但是这种方式可能我们在取值的过程中程序都已经执行到后面的步骤了，那另一种比较精准的方式就是程序执行到某一步骤的时候主动通知，这就是观察者模式。一般被观察者被称为（`Subject`主题），观察者被称为（`Observer`）

```java
// 主题
package concurrent.phase2;

import java.util.ArrayList;
import java.util.List;

public class Subject1 {

    //一个主题中维护了多个观察者
    private List<Observer1> observers = new ArrayList<>();

    private int state;

    public int getState() {
        return this.state;
    }

    public void setState(int state) {
        if (state == this.state) {
            return;
        }
        this.state = state;
        //状态变化时通知所有观察者
        notifyAllObservers();
    }

    public void attach(Observer1 observer) {
        observers.add(observer);
    }

    private void notifyAllObservers() {
        observers.forEach(Observer1::update);
    }
}
```



```java
// 观察者
package concurrent.phase2;

public abstract class Observer1 {

    protected Subject1 subject;

    public Observer1(Subject1 subject) {
        this.subject = subject;
        subject.attach(this);
    }

    public abstract void update();
}

--------
package concurrent.phase2;

public class BinaryObserver extends Observer1 {

    public BinaryObserver(Subject1 subject) {
        super(subject);
    }

    @Override
    public void update() {
        System.out.println("Binary Observer: " + Integer.toBinaryString(subject.getState()));
    }
}
--------
package concurrent.phase2;

public class OctalObserver extends Observer1 {

    public OctalObserver(Subject1 subject) {
        super(subject);
    }

    @Override
    public void update() {
        System.out.println("Octal Observer: " + Integer.toOctalString(subject.getState()));
    }
}
```



```java
package concurrent.phase2;

public class ObserverClient1 {

    public static void main(String[] args) {
        final Subject1 subject = new Subject1();
        BinaryObserver binaryObserver = new BinaryObserver(subject);
        OctalObserver octalObserver = new OctalObserver(subject);
        System.out.println("--------------");
        subject.setState(10);
    }
}
```

当然其实还可以更简单一些：

```java
//观察者
package concurrent.phase2;
public interface Observer1 {
    void update(int state);
}

//主题
package concurrent.phase2;

import java.util.ArrayList;
import java.util.List;

public class Subject1 {

    private List<Observer1> observers = new ArrayList<>();

    private int state;

    public int getState() {
        return this.state;
    }

    public void setState(int state) {
        if (state == this.state) {
            return;
        }
        this.state = state;
        notifyAllObservers();
    }

    public void attach(Observer1 observer) {
        observers.add(observer);
    }

    private void notifyAllObservers() {
        observers.forEach(s -> s.update(this.state));
    }
}

//应用
package concurrent.phase2;

public class ObserverClient1 {

    public static void main(String[] args) {
        final Subject1 subject = new Subject1();
        subject.attach(state -> System.out.println("Binary Observer: " + Integer.toBinaryString(state)));
        subject.attach(state -> System.out.println("Octal Observer: " + Integer.toOctalString(state)));
        subject.setState(10);

    }
}
```



下面看多线程中的应用

```java
//主题
package concurrent.phase2;

public abstract class Subject2 implements Runnable {

    //这里只是维护了一个观察者
    final protected Observer2 subject;

    public Subject2(final Observer2 subject) {
        this.subject = subject;
    }

    protected void notifyChange(final RunnableEvent event) {
        subject.onEvent(event);

    }

    public enum RunnableState {
        RUNNING, ERROR, DONE
    }

    public static class RunnableEvent {

        private final RunnableState state;
        private final Thread thread;
        private final Throwable cause;

        public RunnableEvent(RunnableState state, Thread thread, Throwable cause) {
            this.state = state;
            this.thread = thread;
            this.cause = cause;
        }

        public RunnableState getState() {
            return state;
        }

        public Thread getThread() {
            return thread;
        }

        public Throwable getCause() {
            return cause;
        }
    }
}
```



```java
//观察者接口
package concurrent.phase2;

import concurrent.phase2.Subject2.RunnableEvent;

public interface Observer2 {
    void onEvent(RunnableEvent event);
}
-------
//观察者
package concurrent.phase2;

import concurrent.phase2.Subject2.RunnableEvent;
import java.util.List;

public class ThreadLifeCycleObserver implements Observer2 {

    private final Object LOCK = new Object();

    /**
     * 这里启动几个线程，并监控其状态
     */
    public void concurrentQuery(List<String> ids) {
        if (ids == null || ids.isEmpty()) {
            return;
        }
        ids.forEach(id -> new Thread(new Subject2(this) {
            @Override
            public void run() {
                try {
                    notifyChange(new RunnableEvent(RunnableState.RUNNING, Thread.currentThread(), null));
                    System.out.println("query for the id " + id);
                    notifyChange(new RunnableEvent(RunnableState.DONE, Thread.currentThread(), null));
                } catch (Exception e) {
                    notifyChange(new RunnableEvent(RunnableState.ERROR, Thread.currentThread(), e));
                }
            }
        }, id).start());
    }

    @Override
    public void onEvent(RunnableEvent event) {
        synchronized (LOCK) {
            System.out.println("The runnable [ " + event.getThread().getName()
                + " ] data change and state is " + event.getState());
            if (event.getCause() != null) {
                System.out.println("The runnable [ " + event.getThread().getName()
                    + " ] process failed");
                event.getCause().printStackTrace();
            }
        }
    }
}
```



```java
package concurrent.phase2;

import java.util.Arrays;

public class ObserverClient2 {
    public static void main(String[] args) {
        ThreadLifeCycleObserver observer = new ThreadLifeCycleObserver();
        observer.concurrentQuery(Arrays.asList("1", "2"));
    }
}
```

这里就是只有一个观察者，此观察者启动了两个线程（分别对应其各自的主题），然后监控两个线程的生命周期。当线程状态发生变化的时候通知观察者。**基本写法就是在主题中维护观察者，然后当自己的状态发生变化时通知观察者。**同时还可以看到在上面的观察者中可以看到维护了一个锁，当多个线程或者说多个主题都来通知时需要先获取到锁才能进行状态变化通知。



## 单线程执行设计模式

多线程问题发生一般需要几个条件：有共享资源、存在临界值、多个线程发生竞争

```java
package concurrent.phase2;

public class Gate {

    private int counter = 0;

    //共享资源
    private String name = "no body";
    private String address = "no where";

    /**
     * 临界值
     */
    public void pass(String otherName, String otherAddress) {
        this.counter++;
        //竞争
        this.name = otherName;
        this.address = otherAddress;
        verify();
    }

    private void verify() {
        if (this.name.charAt(0) != this.address.charAt(0)) {
            System.out.println("------BROKEN----------" + toString());
        }
    }

    @Override
    public String toString() {
        return "Gate{" +
            "counter=" + counter +
            ", name='" + name + '\'' +
            ", address='" + address + '\'' +
            '}';
    }
}
```



```java
package concurrent.phase2;

public class UseGate extends Thread{

    private final Gate gate;

    private final String name;

    private final String address;

    public UseGate(String name, String address, Gate gate) {
        this.name = name;
        this.address = address;
        this.gate = gate;
    }

    @Override
    public void run() {
        System.out.println(name + " begin");
        while (true) {
            this.gate.pass(name, address);
        }
    }
}
```



```java
package concurrent.phase2;

public class Client1 {
    public static void main(String[] args) {
        Gate gate = new Gate();
        UseGate bj = new UseGate("Baobao", "Beijing", gate);
        UseGate sh = new UseGate("Shanglao", "Shanghai", gate);
        UseGate gz = new UseGate("Guanglao", "Guangzhou", gate);

        bj.start();
        sh.start();
        gz.start();
    }
}
```

上面这个例子就很好的展示了这种问题。只需要排除其中一个条件就可以排除多线程的问题，这里我们在`pass`和`toString`方法上加上`synchronize`同步即可，当然这其实相当于在`verify`上面也加了锁。但是这里有个问题就是，其实对于`verify`和`toString`方法来说，只是对共享资源的一个读操作，都加锁则会导致效率较低的问题。



## 读写锁

为了效率一般情况下对于多个线程的“读-读”操作是不需要加锁的，而对于“读-写”和“写-写”操作是需要加锁的。这个在读操作比较多的场景中是比较适合的。





















