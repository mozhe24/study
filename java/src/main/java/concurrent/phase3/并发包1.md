# `ForkJoin`

此框架一般有两个工具是我们经常使用的，一个是有返回值的`RecursiveTask`，另一个是无返回值的`RecursiveAction`。下面看一个累加的基本例子

```java
package concurrent.phase3;

import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.RecursiveTask;
import java.util.stream.IntStream;

public class Demo15 {

    private final static int MAX_THRESHOLD = 3;

    private static class CalculatedRecursiveTask extends RecursiveTask<Integer> {

        private final int start;

        private final int end;

        public CalculatedRecursiveTask(int start, int end) {
            this.start = start;
            this.end = end;
        }

        @Override
        protected Integer compute() {
            if (end - start <= MAX_THRESHOLD) {
                return IntStream.rangeClosed(start, end).sum();
            } else {
                int middle = start + (end - start) / 2;
                CalculatedRecursiveTask left = new CalculatedRecursiveTask(start, middle);
                CalculatedRecursiveTask right = new CalculatedRecursiveTask(middle + 1, end);
                left.fork();
                right.fork();
                return left.join() + right.join();
            }
        }
    }

    public static void main(String[] args) {
        final ForkJoinPool forkJoinPool = new ForkJoinPool();
        ForkJoinTask<Integer> future = forkJoinPool.submit(new CalculatedRecursiveTask(1, 10));
        try {
            Integer result = future.get();
            System.out.println(result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```java
package concurrent.phase3;

import java.util.Optional;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.IntStream;

public class Demo16 {

    private final static int MAX_THRESHOLD = 3;

    private final static AtomicInteger SUM = new AtomicInteger(0);

    public static void main(String[] args) {
        final ForkJoinPool pool = new ForkJoinPool();
        pool.submit(new CalculatedRecursiveAction(0, 10));
        try {
            pool.awaitTermination(10, TimeUnit.SECONDS);
            Optional.of(SUM).ifPresent(System.out::println);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static class CalculatedRecursiveAction extends RecursiveAction {

        private final int start;

        private final int end;

        public CalculatedRecursiveAction(int start, int end) {
            this.start = start;
            this.end = end;
        }

        @Override
        protected void compute() {
            if (end - start <= MAX_THRESHOLD) {
                SUM.addAndGet(IntStream.rangeClosed(start, end).sum());
            } else {
                int middle = start + (end - start) / 2;
                CalculatedRecursiveAction left = new CalculatedRecursiveAction(start, middle);
                CalculatedRecursiveAction right = new CalculatedRecursiveAction(middle + 1, end);
                left.fork();
                right.fork();
                left.join();
                right.join();
            }
        }
    }
}
```

参考：`https://cloud.tencent.com/developer/article/1625131`

整体思路就是分治累加+任务窃取。

`Fork/Join` 使用两个类来完成以上两件事情：

* `ForkJoinTask`：我们要使用 `ForkJoin` 框架，必须首先创建一个` ForkJoin` 任务。它提供在任务中执行 `fork()` 和 `join()` 操作的机制，通常情况下我们不需要直接继承 `ForkJoinTask` 类，而只需要继承它的子类，`Fork/Join` 框架提供了以下两个子类：
    * `RecursiveAction`：用于没有返回结果的任务。
    * `RecursiveTask` ：用于有返回结果的任务。
* `ForkJoinPool` ：`ForkJoinTask` 需要通过 `ForkJoinPool` 来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。



## 构造函数

```java
public ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory, UncaughtExceptionHandler handler, boolean asyncMode)
```

* `parallelism`：可并行级别，`Fork/Join`框架将依据这个并行级别的设定，决定框架内并行执行的线程数量。并行的每一个任务都会有一个线程进行处理，但是千万不要将这个属性理解成`Fork/Join`框架中最多存在的线程数量，也不要将这个属性和`ThreadPoolExecutor`线程池中的`corePoolSize、maximumPoolSize`属性进行比较，因为`ForkJoinPool`的组织结构和工作方式与后者完全不一样。而后续的讨论中，读者还可以发现`Fork/Join`框架中可存在的线程数量和这个参数值的关系并不是绝对的关联（有依据但并不全由它决定）。

* `factory`：当`Fork/Join`框架创建一个新的线程时，同样会用到线程创建工厂。只不过这个线程工厂不再需要实现`ThreadFactory`接口，而是需要实现`ForkJoinWorkerThreadFactory`接口。后者是一个函数式接口，只需要实现一个名叫`newThread`的方法。在`Fork/Join`框架中有一个默认的`ForkJoinWorkerThreadFactory`接口实现：`DefaultForkJoinWorkerThreadFactory`。

* `handler`：异常捕获处理器。当执行的任务中出现异常，并从任务中被抛出时，就会被`handler`捕获。

* `asyncMode`：这个参数也非常重要，从字面意思来看是指的异步模式，它并不是说`Fork/Join`框架是采用同步模式还是采用异步模式工作。`Fork/Join`框架中为每一个独立工作的线程准备了对应的待执行任务队列，这个任务队列是使用数组进行组合的双向队列。即是说存在于队列中的待执行任务，即可以使用先进先出的工作模式，也可以使用后进先出的工作模式。当`asyncMode`设置为`ture`的时候，队列采用先进先出方式工作；反之则是采用后进先出的方式工作，该值默认为`false`。如果你对`Fork/Join`框架没有特定的执行要求，可以直接使用不带有任何参数的构造函数。也就是说推荐基于当前操作系统可以使用的`CPU`内核数作为`Fork/Join`框架内最大并行任务数量，这样可以保证`CPU`在处理并行任务时，尽量少发生任务线程间的运行状态切换



实例化`ForkJoinPool`一般不推荐使用`new`，而是使用

```java
ForkJoinPool commonPool =  ForkJoinPool.commonPool();
```

这个静态方法所获得的`ForkJoinPools`实例是由整个应用进程共享的，并且它适合绝大多数的应用系统场景。使用`commonPool`通常可以帮助应用程序中多种需要进行归并计算的任务共享计算资源，从而使后者发挥最大作用（`ForkJoinPools`中的工作线程在闲置时会被缓慢回收，并在随后需要使用时被恢复），而这种获取`ForkJoinPools`实例的方式，才是`Doug Lea`推荐的使用方式。



## `ForkJoinPool` 提交任务的方式对比

| 方法名                    | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| `invoke(ForkJoinTask t)`  | 提交任务并一直阻塞直到任务执行完成返回合并结果。             |
| `execute(ForkJoinTask t)` | 异步执行任务，无返回值。                                     |
| `submit(ForkJoinTask t)`  | 异步执行任务，返回`task`本身，可以通过`task.get()`方法获取合并之后的结果 |

```java
// 这是一个同步方法，有返回值
public <T> T invoke(ForkJoinTask<T> task) {
    if (task == null)
        throw new NullPointerException();
    externalPush(task);
    return task.join();
}
// 这里异步执行，无返回值
public void execute(ForkJoinTask<?> task) {
    if (task == null)
        throw new NullPointerException();
    externalPush(task);
}
// 异步有返回值
public <T> ForkJoinTask<T> submit(ForkJoinTask<T> task) {
    if (task == null)
        throw new NullPointerException();
    externalPush(task);
    return task;
}
```



## 工作线程和工作队列

`ForkJoinPool`中的工作线程采用的是`ForkJoinWorkerThread`。它继承了`Thread`类。内部有两个非常关键的变量如下：

```java
final ForkJoinPool pool;                // the pool this thread works in
final ForkJoinPool.WorkQueue workQueue; // work-stealing mechanics
```

`pool`表示这个工作线程所属的`ForkJoinPool`实例；

`workQueue`表示与这个工作线程对应的待执行子任务队列。 `WorkQueue`是`ForkJoinPool`的一个内部类，它并没有像`Java`中的其他队列那样，继承`BlockingQueue`提供`offer/poll`等方法来入队和出队。而是基于双端链表单独实现的，提供了`push()/pop()`方法来操作，队列中的元素其实就是被分割的子任务。它支持任务窃取，这一切的操作也必须要求是线程安全的，因此内部也大量的应用到了`UnSafe`基础类来保障线程安全。

队列在执行的过程中，如果发生阻塞，可以将其暂时放在一边，然后去执行其依赖的其他子任务，按照队列中的处理顺序就是每次都处理**最后添加到队列中的任务（LIFO）**。而如果其他队列中的人物已被执行完，那么就会进行任务窃取，然后执行，窃取时遵循（FIFO），也就是窃取最老的任务。







# `Phaser`

此工具和之前的`CountDownLatch, CyclicBarrier`比较类似，但是功能相比起来要强一些。

```java
// 对比CountDownLatch
package concurrent.phase3;

import java.util.Random;
import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

public class Demo17 {

    private static final Random random = new Random(System.currentTimeMillis());

    static class Task extends Thread{
        private final Phaser phaser;

        public Task(Phaser phaser) {
            this.phaser = phaser;
            //task进来之后先要注册，而不是一开始就固定好有几个线程
            this.phaser.register();
            start();
        }

        @Override
        public void run() {
            System.out.println("The worker [" + getName() + "] is working...");
            try {
                TimeUnit.SECONDS.sleep(random.nextInt(5));
                // 这里相当于CountDownLatch的await方法
                this.phaser.arriveAndAwaitAdvance();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        Phaser phaser = new Phaser();
        IntStream.rangeClosed(1, 5).boxed().map(e -> phaser).forEach(Task::new);
        // 这里将main线程也注册进来，相比起来这里可以动态的添加，
        // 而CountDownLatch和CyclicBarrier则需要一开始就确定
        // 同时还可以使用bulkRegister批量注册
        phaser.register();
        phaser.arriveAndAwaitAdvance();
        System.out.println("task done");
    }
}
```



```java
// 对比CyclicBarrier
package concurrent.phase3;

import java.util.Random;
import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;

/**
 * 这里模拟CyclicBarrier的使用，其中计数器可以重复使用。
 * 比如这里有假设有多个线程先需要所有人参加完长跑，然后再进行自行车比赛，然后再进行跳高。
 * 这就好比三个比赛阶段
 */
public class Demo18 {

    private static final Random random = new Random(System.currentTimeMillis());

    static class Athlete extends Thread{

        private final int no;
        private final Phaser phaser;

        public Athlete(int no, Phaser phaser) {
            this.no = no;
            this.phaser = phaser;
        }

        @Override
        public void run() {
            try {
                doPhaseWork(": start running.", ": end running.");
                doPhaseWork(": start bicycle.", ": end bicycle.");
                doPhaseWork(": start jump.", ": end jump.");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        private void doPhaseWork(String s, String s2) throws InterruptedException {
            System.out.println(no + s);
            TimeUnit.SECONDS.sleep(random.nextInt(5));
            System.out.println(no + s2);
            phaser.arriveAndAwaitAdvance();
        }
    }

    public static void main(String[] args) {
        // 一次性注册5个线程，不需要使用register方法注册
        Phaser phaser = new Phaser(5);
        for (int i = 0; i < 5; i++) {
            new Athlete(i, phaser).start();
        }
    }
}
```

这里可以看到计数器是可以重复使用的。但是如果说其中有一个人中途受伤了，无法参加跳高了

```java
package concurrent.phase3;

import java.util.Random;
import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;

/**
 * 这里模拟CyclicBarrier的使用，其中计数器可以重复使用。
 * 比如这里有假设有多个线程先需要所有人参加完长跑，然后再进行自行车比赛，然后再进行跳高。
 * 这就好比三个比赛阶段，但是这里可能和之前不一样，有一个人可能受伤了，无法参加最后的跳高
 */
public class Demo19 {

    private static final Random random = new Random(System.currentTimeMillis());

    static class AthleteInjured extends Thread{

        private final int no;
        private final Phaser phaser;

        public AthleteInjured(int no, Phaser phaser) {
            this.no = no;
            this.phaser = phaser;
        }

        @Override
        public void run() {
            try {
                doPhaseWork(": start running.", ": end running.");
                doPhaseWork(": start bicycle.", ": end bicycle.");
                System.out.println("I'm injured");
                //退出，解除注册
                this.phaser.arriveAndDeregister();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        private void doPhaseWork(String s, String s2) throws InterruptedException {
            System.out.println(no + s);
            TimeUnit.SECONDS.sleep(random.nextInt(5));
            System.out.println(no + s2);
            phaser.arriveAndAwaitAdvance();
        }
    }

    static class Athlete extends Thread{

        private final int no;
        private final Phaser phaser;

        public Athlete(int no, Phaser phaser) {
            this.no = no;
            this.phaser = phaser;
        }

        @Override
        public void run() {
            try {
                doPhaseWork(": start running.", ": end running.");
                doPhaseWork(": start bicycle.", ": end bicycle.");
                doPhaseWork(": start jump.", ": end jump.");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        private void doPhaseWork(String s, String s2) throws InterruptedException {
            System.out.println(no + s);
            TimeUnit.SECONDS.sleep(random.nextInt(5));
            System.out.println(no + s2);
            phaser.arriveAndAwaitAdvance();
        }
    }

    public static void main(String[] args) {
        // 一次性注册5个线程
        Phaser phaser = new Phaser(5);
        for (int i = 0; i < 4; i++) {
            new Athlete(i, phaser).start();
        }
        new AthleteInjured(4, phaser).start();
    }
}
```

那还有这样一种场景，就是将一个几个线程去执行某个任务，而这个任务可以分为几个阶段，对于主线程来说，我只是关系这些线程的第一个阶段的完成情况，对于其他阶段的完成并不关心

```java
package concurrent.phase3;

import java.util.Random;
import java.util.concurrent.Phaser;
import java.util.concurrent.TimeUnit;

public class Demo20 {

    private static final Random random = new Random(System.currentTimeMillis());

    static class Athlete extends Thread{

        private final int no;
        private final Phaser phaser;

        public Athlete(int no, Phaser phaser) {
            this.no = no;
            this.phaser = phaser;
        }

        @Override
        public void run() {
            try {
                System.out.println(no + ": start first work");
                TimeUnit.SECONDS.sleep(random.nextInt(5));
                System.out.println(no + ": end first work");
                // 此方法并不会阻塞，同时也不会对计数器进行变更
                phaser.arrive();

                System.out.println(no + ": start second work");
                TimeUnit.SECONDS.sleep(random.nextInt(5));
                System.out.println(no + ": end second work");

                phaser.arriveAndAwaitAdvance();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        // 一次性注册4个线程
        Phaser phaser = new Phaser(5);
        for (int i = 0; i < 4; i++) {
            new Athlete(i, phaser).start();
        }
        phaser.arriveAndAwaitAdvance();
        System.out.println("the first phase work done");
    }
}
```





# `ExecutorService`

先看下基本创建方式

```java
package concurrent.phase3;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.ThreadPoolExecutor.AbortPolicy;
import java.util.concurrent.TimeUnit;

public class Demo21 {

    public static void main(String[] args) {
        ThreadPoolExecutor pool = test1();
        int activeAccount = -1;
        int queueSize = -1;
        while (true) {
            if (activeAccount != pool.getActiveCount() || queueSize != pool.getQueue().size()) {
                System.out.println("活跃线程数: " + pool.getActiveCount());
                System.out.println("核心线程数: " + pool.getCorePoolSize());
                System.out.println("队列线程数: " + pool.getQueue().size());
                System.out.println("最大线程数: " + pool.getMaximumPoolSize());
                activeAccount = pool.getActiveCount();
                queueSize = pool.getQueue().size();
                System.out.println("-------------------");
            }
        }
    }

    public static ThreadPoolExecutor test1() {
        ThreadPoolExecutor pool = new ThreadPoolExecutor(1, 2, 30, TimeUnit.SECONDS,
            new ArrayBlockingQueue<Runnable>(1),
            r -> {
                Thread t = new Thread(r);
                return t;
            }, new AbortPolicy());
        System.out.println("the thread pool created done");
        // 通过提交不同数量线程来检测
        pool.execute(() -> sleepSeconds(100));
        pool.execute(() -> sleepSeconds(10));
        pool.execute(() -> sleepSeconds(100));
        return pool;
    }

    private static void sleepSeconds(long sec) {
        try {
            System.out.println("* " + Thread.currentThread().getName() + " *");
            TimeUnit.SECONDS.sleep(sec);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```



```java
package concurrent.phase3;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.ThreadPoolExecutor.AbortPolicy;
import java.util.concurrent.TimeUnit;
import java.util.stream.IntStream;

public class Demo22 {

    public static void main(String[] args) {
        ThreadPoolExecutor pool = new ThreadPoolExecutor(10, 20, 30, TimeUnit.SECONDS,
            new ArrayBlockingQueue<Runnable>(10),
            r -> {
                Thread t = new Thread(r);
                return t;
            }, new AbortPolicy());

        IntStream.range(0, 20).boxed().forEach(i -> pool.execute(() -> {
            try {
                TimeUnit.SECONDS.sleep(10);
                System.out.println("* " + Thread.currentThread().getName() + " ->" + i + " done");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }));
        // 表示将线程池停止，但是是非阻塞的，需要当前工作的所有线程执行完，而队列中的线程不会提交，直接退出，无返回值
        // 而shutdownNow则会将正在工作都线程处理完，同样不会再执行queue中的线程，而是将队列中的线程返回出去，也是非阻塞的
        pool.shutdown();

        // 如果想在这里阻塞住
        try {
            // 设置一个最大等待时间，若线程都执行完了则不会继续等待
            pool.awaitTermination(1, TimeUnit.HOURS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

这里要注意`shutDown`和`shutDownNow`的区别：

当前提交20个线程，10个在工作中，10个在队列中，若此时调用`shutDown`，则会发生首先等待10个正在工作的线程执行完，然后将所有20个线程全部打断退出。此时若调用`shutDownNow`则首先会尝试打断正在工作的10个线程，然后打断退出，并将队列中的10个线程返回出去。

有时候可能在线程执行的时候卡住了导致无法停止线程池，此时可以在创建线程的工厂方法中设置线程为守护线程，这样是一种避免卡死的方式。























