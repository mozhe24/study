

##1.`Cookie` 和` Session`的区别

`Cookies`是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。具体来说`cookie`机制采用的是在客户端保持状态的方案。它是在用户端的会话状态的存贮机制，他需要用户打开客户端的`cookie`支持。`session`机制采用的是一种在服务器端保持状态的解决方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以`session`机制可能需要借助于`cookie`机制来达到保存标识的目的。而`session`提供了方便管理全局变量的方式 。



## 2.`fail-fast` 与` fail-safe `机制有什么区别

什么是同步修改？

当一个或多个线程正在遍历一个集合`Collection`，此时另一个线程修改了这个集合的内容（添加，删除或者修改）。这就是并发修改

什么是 `fail-fast` 机制?

`fail-fast`机制在遍历一个集合时，当集合结构被修改，会抛出`Concurrent Modification Exception`。`fail-fast`会在以下两种情况下抛出`ConcurrentModificationException`

（1）单线程环境：集合被创建后，在遍历它的过程中修改了结构。注意 `remove()`方法会让`expectModcount`和`modcount `相等，所以是不会抛出这个异常。

（2）多线程环境：当一个线程在遍历这个集合，而另一个线程对这个集合的结构进行了修改。

`fail-safe`任何对集合结构的修改都会在一个复制的集合上进行修改，因此不会抛出`ConcurrentModificationException`

`fail-safe`机制有两个问题

（1）需要复制集合，产生大量的无效对象，开销大

（2）无法保证读取的数据是目前原始数据结构中的数据。



## 3.`get` 和` post`请求的区别

`GET`和`POST`本质上就是`TCP`链接，并无差别。但是由于`HTTP`的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。` GET`和`POST`还有一个重大区别，简单的说：`GET`产生一个TCP数据包；`POST`产生两个`TCP`数据包。对于`GET`方式的请求，浏览器会把`http header`和`data`一并发送出去，服务器响应`200`（返回数据）； 而对于`POST`，浏览器先发送`header`，服务器响应`100 continue`，浏览器再发送`data`，服务器响应`200 ok`（返回数据）。



## 4.`IOC`的优点是什么

`ioc`的思想最核心的地方在于，资源不由资源的使用方管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。

## 5.`IO` 和 `NIO`的区别，`NIO`优点

传统的`socket IO`（阻塞）中，需要为每个连接创建一个线程，当并发的连接数量非常巨大时，线程所占用的栈内存和`CPU`线程切换的开销将非常巨大。使用`NIO`（非阻塞），不再需要为每个线程创建单独的线程，可以用一个含有限数量线程的线程池，甚至一个线程来为任意数量的连接服务。由于线程数量小于连接数量，所以每个线程进行`IO`操作时就不能阻塞，如果阻塞的话，有些连接就得不到处理，`NIO`提供了这种非阻塞的能力。

(1)`IO`是面向流的，`NIO`是面向缓冲区的
`Java IO`面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方；
`NIO`则能前后移动流中的数据，因为是面向缓冲区的

(2)`IO`流是阻塞的，`NIO`流是不阻塞的
`Java IO`的各种流是阻塞的。这意味着，当一个线程调用`read()` 或` write()`时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了
`Java NIO`的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。`NIO`可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。

(3)选择器
`Java NIO`的选择器（`Selector`）允许一个单独的线程来监视多个输入通道（`Channel`），你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。

`NIO`的优势：
1.优势在于一个线程管理多个通道；但是数据的处理将会变得复杂；
2.如果需要管理同时打开的成千上万个连接，这些连接每次只是发送少量的数据，采用这种；

传统`IO`的优势：
1.适用于一个线程管理一个通道的情况；因为其中的流数据的读取是阻塞的；
2.如果需要管理同时打开不太多的连接，这些连接会发送大量的数据；



## 6.什么是竞态条件和临界区

当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。



## 7.`JRE、JDK、JVM `及 `JIT` 之间有什么不同

`java`虚拟机(`JVM`)：`Java`应用程序的运行环境
`java`运行时环境(`JRE`)：`java`运行时环境是`JVM`的一个超集。`JVM`对于一个平台或者操作系统是明确的，而`JRE`确实一个一般的概念，他代表了完整的运行时环境。
`java`开发工具箱(`JDK`)：`java`开发工具箱指的是编写一个`java`应用所需要的所有`jar`文件和可执行文件。事实上，`JRE`是`JKD`的一部分。
即时编译器(`JIT`)：即时编译器是种特殊的编译器，它通过有效的把字节码变成机器码来提高`JVM`的效率。



## 8.`RPC` 通信和` RMI `区别

远程对象方法调用并不是新概念，远程过程调用 (`RPC-remote procedure call`) 已经使用很多年了。远程过程调用被设计为在应用程序间通信的平台中立的方式，它不理会操作系统之间以及语言之间的差异。即 `RPC` 支持多种语言，而 `RMI(Remote Method Invocation)`只支持 `Java` 写的应用程序。另外` RMI `调用远程对象方法，允许方法返回` Java `对象以及基本数据类型。而` RPC `不支持对象的概念，传送到` RPC `服务的消息由外部数据表示 (`External Data Representation, XDR`) 语言表示，这种语言抽象了字节序类和数据类型结构之间的差异。只有由` XDR` 定义的数据类型才能被传递， `RPC `不允许传递对象。可以说 `RMI `是面向对象方式的` Java RPC` 。



## 9.一个`.java`源文件中是否可以包含多个类（不是内部类）？有什么限制

这个是可以的，一个`.java`源文件里面可以包含多个类，但是只允许有一个`public`类，并且类名必须和文件名一致。每个编译单元只能有一个`public `类。这么做的意思是，每个编译单元只能有一个公开的接口，而这个接口就由其`public `类来表示。你可以根据需要，往这个文件里面添加任意多个提供辅助功能的`package` 权限的类。但是如果这个编译单元里面有两个或两个以上的`public `类的话，程序就不知道从哪里导入了，编译器就会报错。



## 10.类加载器，是否实现过类加载器

参考：[深入理解Java类加载器](../java/note/jvm/Java 虚拟机.md)



## 11.解释一下什么叫`AOP`（面向切面编程）

`AOP`不一定都像`Spring AOP`那样，是在运行时生成代理对象来织入的，还可以在编译期、类加载期织入，比如`AspectJ`。`AOP`像`OOP`一样，只是一种编程范式。该范型以一种称为切面（`aspect`）的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点（`crosscutting concern`）。



## 12.请简述 `Servlet` 的生命周期及其相关的方法

`init()`方法
在`Servlet`的生命周期中，仅执行一次`init()`方法，它是在服务器装入`Servlet`时执行的，可以配置服务器，以在启动服务器或客户机首次访问`Servlet`时装入`Servlet`。无论有多少客户机访问`Servlet`，都不会重复执行`init()；`

`service()`方法
它是`Servlet`的核心，每当一个客户请求一个`HttpServlet`对象，该对象的`Service()`方法就要调用，而且传递给这个方法一个“请求”（`ServletRequest`）对象和一个“响应”（`ServletResponse`）对象作为参数。在`HttpServlet`中已存在`Service()`方法。默认的服务功能是调用与`HTTP`请求的方法相应的`do`功能。

`destroy()`方法
仅执行一次，在服务器端停止且卸载`Servlet`时执行该方法，有点类似于`C++`的`delete`方法。一个`Servlet`在运行`service()`方法时可能会产生其他的线程，因此需要确认在调用`destroy()`方法时，这些线程已经终止或完成。



## 13.`finalize`

垃圾回收器准备释放内存的时候，会先调用`finalize()`。
(1).对象不一定会被回收。
(2).垃圾回收不是析构函数。
(3).垃圾回收只与内存有关。
(4).垃圾回收和`finalize()`都是靠不住的，只要`JVM`还没有快到耗尽内存的地步，它是不会浪费时间进行垃圾回收的。


## 14.`final`

当用`final`修饰一个类时，表明这个类不能被继承。

使用`final`方法的原因有两个：第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的`Java`实现版本中，会将`final`方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的`Java`版本中，不需要使用`final`方法进行这些优化了。

对于一个`final`变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。



## 15.`volatile`

对一个共享变量使用`Volatile`关键字保证了线程间对该数据的可见性，即不会读到脏数据。
1. 可见性：对一个`volatile`变量的读，总是能看到（任意线程）对这个`volatile`变量最后的写入
2. 原子性：对任意单个`volatile`变量的读/写具有原子性(`long,double`这2个8字节的除外)，但类似于`volatile++`这种复合操作不具有原子性。
3. `volatile`修饰的变量如果是对象或数组之类的，其含义是对象获数组的地址具有可见性，但是数组或对象内部的成员改变不具备可见性



## 16.是否可以覆盖(`override`)一个`private`或者是`static`的方法

`static`表示静态的意思，可用于修饰成员变量和成员函数，被静态修饰的成员函数只能访问静态成员，不可以访问非静态成员。静态是随着类的加载而加载的，因此可以直接用类进行访问。重写是子类中的方法和子类继承的父类中的方法一样（函数名，参数，参数类型，反回值类型），但是子类中的访问权限要不低于父类中的访问权限。重写的前提是必须要继承，`private`修饰不支持继承，因此被私有的方法不可以被重写。静态方法形式上可以被重写，即子类中可以重写父类中静态的方法。但是实际上从内存的角度上静态方法不可以被重写。

## 17.`main() `方法为什么必须是静态的？能不能声明 `main() `方法为非静态

因为`main()`方法是由`Java`虚拟机调用的，所以必须是`public`，虚拟机调用的`main()`方法的时候，不需要产生任何对象，所以`main()`方法声明为`static`，且不需要返回值，所以必须声明为`void`



## 18.类加载顺序

如果类还没有被加载： 
1、先执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。 
2、执行子类的静态代码块和静态变量初始化。 
3、执行父类的实例变量初始化 
4、执行父类的构造函数 
5、执行子类的实例变量初始化 
6、执行子类的构造函数 

如果类已经被加载： 
则静态代码块和静态变量就不用重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。



## 19.`BlockingQueue`用法

如果`BlockingQueue`是空的,从`BlockingQueue`取东西的操作将会被阻断进入等待状态,直到`BlockingQueue`进了东西才会被唤醒.同样,如果`BlockingQueue`是满的,任何试图往里存东西的操作也会被阻断进入等待状态,直到`BlockingQueue`里有空间才会被唤醒继续操作. 使用BlockingQueue的关键技术点如下:  

`BlockingQueue`有四个具体的实现类,根据不同需求,选择不同的实现类 
1)`ArrayBlockingQueue`:规定大小的`BlockingQueue`,其构造函数必须带一个int参数来指明其大小.其所含的对象是以`FIFO`(先入先出)顺序排序的. 
2)`LinkedBlockingQueue`:大小不定的`BlockingQueue`,若其构造函数带一个规定大小的参数,生成的`BlockingQueue`有大小限制,若不带大小参数,所生成的`BlockingQueue`的大小由`Integer.MAX_VALUE`来决定.其所含的对象是以`FIFO`(先入先出)顺序排序的 
3)`PriorityBlockingQueue`:类似于`LinkedBlockQueue`,但其所含对象的排序不是`FIFO`,而是依据对象的自然排序顺序或者是构造函数的`Comparator`决定的顺序. 
4)`SynchronousQueue`:特殊的`BlockingQueue`,对其的操作必须是放和取交替完成的. 

`LinkedBlockingQueue`和`ArrayBlockingQueue`比较起来,它们背后所用的数据结构不一样,导致`LinkedBlockingQueue`的数据吞吐量要大于`ArrayBlockingQueue`,但在线程数量很大时其性能的可预见性低于`ArrayBlockingQueue`.      



## 20.`String`

1）`String`类是`final`类，也即意味着`String`类不能被继承，并且它的成员方法都默认为`final`方法。在`Java`中，被`final`修饰的类是不允许被继承的，并且该类中的成员方法都默认为`final`方法。
2）`String`类其实是通过`char`数组来保存字符串的。
3）每当我们创建字符串常量时，`JVM`会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于`String`字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。

## 21.`String、StringBuilder`和`StringBuffer`的区别

`String `类型和` StringBuilder  `类型的主要性能区别其实在于 `String `是不可变的对象, 因此在每次对 `String `类型进行改变的时候其实都等同于生成了一个新的` String` 对象，然后将指针指向新的` String `对象，所以经常改变内容的字符串最好不要用` String` ，因为每次生成对象都会对系统性能产生影响。而如果是使用` StringBuilder`类则结果就不一样了，每次结果都会对` StringBuilder`对象本身进行操作，而不是生成新的对象，再改变对象引用。`StringBuffer`线程安全的可变字符序列。一个类似于` String` 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。



## 22. `HashMap`

底层是数组加链表和红黑树。



## 23.`ConcurrentHashMap `

在`java7`中使用段锁实现线程安全，每一个`segment`都是一个`HashEntry<K,V>[] table`，` table`中的每一个元素本质上都是一个`HashEntry`的单向链表，`java8`中对其进行了改进：
改进一：取消`segments`字段，直接采用`transient volatile HashEntry<K,V>[] table`保存数据，采用`table`数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。
改进二：将原先`table`数组＋单向链表的数据结构，变更为`table`数组＋单向链表＋红黑树的结构。

同时还使用`CAS`算法进行了并发控制。



## 24.`HashSet`

底层就是`HashMap`，使用其`keySet`保存相关元素。

## 25.`WeakHashMap`

`WeakHashMap` 里的`entry`可能会被`GC`自动删除，即使程序员没有调用`remove()`或者`clear()`方法。

## 26.一个已经构建好的 `TreeSet`，怎么完成倒排序。
需要用到`TreeSet`的`descendingSet()`方法



## 27.什么是`B`树、 `B+`树，列出实际的使用场景

`B`树和平衡二叉树稍有不同的是`B`树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者`B`树和`B+`树的数据结构，让我们来看看他有什么特点。

`B`树：

（1）排序方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；
（2）子节点数：`非叶节点的子节点数>1，且<=M ，且M>=2`，空树除外（注：`M`阶代表一个树节点最多有多少个查找路径，`M=M`路,当`M=2`则是2叉树,`M=3`则是3叉）；
（3）关键字数：枝节点的关键字数量大于等于`ceil(m/2)-1`个且小于等于`M-1`个（注：`ceil()`是个朝正无穷方向取整的函数 如`ceil(1.1)`结果为2);
（4）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为`null`对应下图最后一层节点的空格子;

`B+`树：

`B+`树是`B`树的一个升级版，相对于`B`树来说`B+`树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说`B+`树查找的效率要比`B`树更高、更稳定；我们先看看两者的区别
（1）`B+`跟`B`树不同，`B+`树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得`B+`树每个非叶子节点所能保存的关键字大大增加；
（2）`B+`树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；
（3）`B+`树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。
（4）非叶子节点的子节点数=关键字数（来源百度百科）（根据各种资料 这里有两种算法的实现方式，另一种为`非叶节点的关键字数=子节点数-1`（来源维基百科)，虽然他们数据排列结构不一样，但其原理还是一样的`Mysql `的`B+`树是用第一种方式实现）;

比较:
1、`B+`树的层级更少：相较于`B`树`B+`每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；
2、`B+`树查询速度更稳定：`B+`所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比`B`树更稳定;
3、`B+`树天然具备排序功能：`B+`树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比`B`树高。
4、`B+`树全节点遍历更快：`B+`树遍历整棵树只需要遍历所有的叶子节点即可，，而不需要像`B`树一样需要对每一层进行遍历，这有利于数据库做全表扫描。


## 28.`Comparator` 与 `Comparable `接口

`Comparable` 在` java.lang `包下，是一个接口，内部只有一个方法` compareTo()`：
`Comparable `可以让实现它的类的对象进行比较，具体的比较规则是按照 `compareTo `方法中的规则进行。这种顺序称为 自然顺序。
`Comparator `在` java.util `包下，也是一个接口，`JDK 1.8 `以前只有两个方法：

```java
public interface Comparator<T> {

    public int compare(T lhs, T rhs);

    public boolean equals(Object object);
}
```

举个例子：

```java
// 1.创建一个实现 Comparator 接口的对象
Comparator comparator = new Comparator() {
    @Override
    public int compare(Object object1, Object object2) {
        if (object1 instanceof NewBookBean && object2 instanceof NewBookBean){
            NewBookBean newBookBean = (NewBookBean) object1;
            NewBookBean newBookBean1 = (NewBookBean) object2;
            //具体比较方法参照 自然排序的 compareTo 方法，这里只举个栗子
            return newBookBean.getCount() - newBookBean1.getCount();
        }
        return 0;
    }
};

//2.将此对象作为形参传递给 TreeSet 的构造器中
TreeSet treeSet = new TreeSet(comparator);

//3.向 TreeSet 中添加 步骤 1 中 compare 方法中设计的类的对象
treeSet.add(new NewBookBean("A",34));
treeSet.add(new NewBookBean("S",1));
treeSet.add( new NewBookBean("V",46));
treeSet.add( new NewBookBean("Q",26));
```

其实可以看到，`Comparator` 的使用是一种策略模式



## 29.如何构建不可变的类结构？关键点在哪里。能创建一个包含可变对象的不可变对象吗

使用`final`。不能创建一个包含可变对象的不可变对象。

## 30.构造器（`constructor`）是否可被重写（`override`）

构造器不是方法，那么用来修饰方法特性的所有修饰符都不能用来修饰构造器（并不等与构造器具备这些特性，虽然不能用`static`修饰构造器，但它却有静态特性）构造器只能用 `public private protected`这三个权限修饰符，且不能有返回语句。



## 31.重写(`Override`)与重载(`Overload`)

重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！重写规则有：

* 参数列表必须完全与被重写方法的相同；
* 返回类型必须完全与被重写方法的返回类型相同；
* 访问权限不能比父类中被重写的方法的访问权限更低。
* 父类的成员方法只能被它的子类重写。
* 声明为`final`的方法不能被重写。
* 声明为`static`的方法不能被重写，但是能够被再次声明。
* 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为`private`和`final`的方法。
* 子类和父类不在同一个包中，那么子类只能够重写父类的声明为`public`和`protected`的非`final`方法。
* 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
* 构造方法不能被重写。
* 如果不能继承一个方法，则不能重写这个方法。



重载(`overload`) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。最常用的地方就是构造器的重载。重载规则:

* 被重载的方法必须改变参数列表(参数个数或类型不一样)；
* 被重载的方法可以改变返回类型；
* 被重载的方法可以改变访问修饰符；
* 被重载的方法可以声明新的或更广的检查异常；
* 方法能够在同一个类中或者在一个子类中被重载。
* 无法以返回值类型作为重载函数的区分标准。





## 32.如何判断一个对象是否存活

通过引用计数算法和可达性分析算法可以判断是否存活



## 33.新老以及永久区是什么

年轻代用来存放新近创建的对象，尺寸随堆大小的增大和减小而相应的变化，可以通过` -XX:NewRatio `来设置年轻代与年老代的大小比例，年青代的特点是对象更新速度快，在短时间内产生大量的“死亡对象”。年轻代的特点是产生大量的死亡对象,并且要是产生连续可用的空间, 所以使用复制清除算法和并行收集器进行垃圾回收.对年轻代的垃圾回收称作初级回收 (`minor gc`)。

老年代里面的对象几乎个个都是在 `Survivor` 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，`Full GC` 发生的次数不会有 `Minor GC `那么频繁，并且做一次` Full GC` 要比进行一次 `Minor GC` 的时间更长。 另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 `GC` 的收集动作。

永久代是`Hotspot`虚拟机特有的概念，是方法区的一种实现，别的`JVM`都没有这个东西。在`Java 8`中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——**元空间**。 永久代或者`“Perm Gen”`包含了`JVM`需要的应用元数据，这些元数据描述了在应用里使用的类和方法。注意，永久代不是`Java`堆内存的一部分。永久代存放`JVM`运行时使用的类。永久代同样包含了`Java SE`库的类和方法。永久代的对象在`full GC`时进行垃圾收集。

## 34.垃圾收集算法

* 标记-清除算法:对所有需要回收的对象（死亡对象）进行标记，然后进行
* 复制算法：将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次性清理掉
* 标记—整理算法：另一种“标记-整理”算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

在新生代中，每次垃圾收集时都发现有大批对象死去，那就选用复制算法。而老年代中因为对象存活率高、没有额外空间对它们进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。




## 35.`Minor GC 、Major GC`与` Full GC`分别在什么时候发生

从年轻代空间（包括 `Eden `和` Survivor `区域）回收内存被称为` Minor GC`。
`Major GC `是清理老年代。
`Full GC `是清理整个堆空间—包括年轻代和老年代。



## 36.`JVM`的永久代中会发生垃圾回收

`hotspot`的方法区存放在永久代中，因此方法区被人们称为永久代。永久代的垃圾回收主要包括类型的卸载和废弃常量池的回收。当没有对象引用一个常量的时候，该常量即可以被回收。而类型的卸载更加复杂。必须满足一下三点，该类型的所有实例都被回收了，该类型的`ClassLoader`被回收了，该类型对应的`java.lang.Class`没有在任何地方被引用，在任何地方都无法通过反射来实例化一个对象



## 37.垃圾回收算法的实现原理

基本原理就是判断对象是否存活来决定某些对象是否需要被回收。



## 38.`JVM`内存分哪几个区，每个区的作用是什么

共享区：方法区和堆

非共享区：虚拟机栈、本地方法栈、程序计数器



## 39.`CyclicBarrier `和 `CountDownLatch`

比如一个线程需要等待前面四个线程执行完毕后才能开始执行，那么我们可以对前面四个线程使用`CountDownLatch`进行计数，当计数达到0时后面一个线程就开始执行。而`CyclicBarrier`实现让一组线程等待至某个状态之后再全部同时执行。



## 40.`sleep() `方法和对象的 `wait()` 方法区别

前者不会释放锁，只是限时等待，后者会将线程加入到等待队列，释放锁，后面等待唤醒之后，再去竞争锁。

## 41.`yield`与`join`方法的区别

`yield`意味着放手，放弃，投降。一个调用`yield()`方法的线程告诉虚拟机它乐意让其他线程占用自己的位置。这表明该线程没有在做一些紧急的事情。注意，这仅是一个暗示，并不能保证不会产生任何影响。
线程实例的方法`join()`方法可以使得一个线程在另一个线程结束后再执行。如果`join()`方法在一个线程实例上调用，当前运行着的线程将阻塞直到这个线程实例完成了执行。使用此方法可以强制运行某个线程。



## 42.什么是线程组，为什么在`Java`中不推荐使用

1.线程组`ThreadGroup`对象中比较有用的方法是`stop、resume、suspend`等方法，由于这几个方法会导致线程的安全问题（主要是死锁问题），已经被官方废弃掉了，所以线程组本身的应用价值就大打折扣了。
2.线程组`ThreadGroup`不是线程安全的，这在使用过程中获取的信息并不全是及时有效的，这就降低了它的统计使用价值。


## 43.`ThreadLocal `原理

`ThreadLoal `变量，线程局部变量，同一个` ThreadLocal `所包含的对象，在不同的` Thread `中有不同的副本。这里有几点需要注意：

因为每个` Thread` 内有自己的实例副本，且该副本只能由当前 `Thread` 使用。这是也是` ThreadLocal `命名的由来。
既然每个 `Thread` 有自己的实例副本，且其它 `Thread `不可访问，那就不存在多线程间共享的问题。
`ThreadLocal `提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。`ThreadLocal` 变量通常被`private static`修饰。当一个线程结束时，它所使用的所有 `ThreadLocal `相对的实例副本都可被回收。

适用于如下两种场景：

* 每个线程需要有自己单独的实例
* 实例需要在多个方法中共享，但不希望被多线程共享



## 44.四种线程池

`newCachedThreadPool`：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
`newFixedThreadPool`：创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
`newScheduledThreadPool`：创建一个定长线程池，支持定时及周期性任务执行，即可以规定间隔多长时间执行。
`newSingleThreadExecutor`：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(`FIFO`, `LIFO`, 优先级)执行。

## 45.线程池的关闭方式有几种，各自的区别是什么

* `shutdown`关闭线程池
    方法定义：`public void shutdown()`
    （1）线程池的状态变成`SHUTDOWN`状态，此时不能再往线程池中添加新的任务，否则会抛出`RejectedExecutionException`异常。
    （2）线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。 
    注意这个函数不会等待提交的任务执行完成，要想等待全部任务完成，可以调用：
    `public boolean awaitTermination(longtimeout, TimeUnit unit)`

* `shutdownNow`关闭线程池并中断任务
    方法定义：`public List<Runnable> shutdownNow()`
    （1）线程池的状态立刻变成`STOP`状态，此时不能再往线程池中添加新的任务。
    （2）终止等待执行的线程，并返回它们的列表；
    （3）试图停止所有正在执行的线程，试图终止的方法是调用`Thread.interrupt()`，但是大家知道，如果线程中没有`sleep 、wait、Condition`、定时锁等应用, `interrupt()`方法是无法中断当前的线程的。所以，`ShutdownNow()`并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。



## 46.线程池中`submit() `和 `execute()`方法有什么区别

`execute`提交的方式
`execute`提交的方式只能提交一个`Runnable`的对象，且该方法的返回值是`void`，也即是提交后如果线程运行后，和主线程就脱离了关系了，当然可以设置一些变量来获取到线程的运行结果。并且当线程的执行过程中抛出了异常通常来说主线程也无法获取到异常的信息的，只有通过`ThreadFactory`主动设置线程的异常处理类才能感知到提交的线程中的异常信息。
`submit`提交的方式有如下三种情况
（1）`<T> Future<T> submit(Callable<T> task);`
（2）`Future<?> submit(Runnable task);`
（3）`<T> Future<T> submit(Runnable task, T result);`
这个接口就比较有意思了，除了`task`之外还有一个`result`对象，当线程正常结束的时候调用`Future`的`get`方法会返回`result`对象，当线程抛出异常的时候会获取到对应的异常的信息。



## 47.`synchronized` 和 `ReentrantLock `有什么不同

1、`ReentrantLock `拥有`Synchronized`相同的并发性和内存语义，此外还多了锁投票，定时锁等候和中断锁等候
2、`synchronized`是在`JVM`层面上实现的，不但可以通过一些监控工具监控`synchronized`的锁定，而且在代码执行时出现异常，`JVM`会自动释放锁定，但是使用`Lock`则不行，`lock`是通过代码实现的，要保证锁定一定会被释放，就必须将`unLock()`放到`finally{}`中
3、在资源竞争不是很激烈的情况下，`Synchronized`的性能要优于`ReetrantLock`，但是在资源竞争很激烈的情况下，`Synchronized`的性能会下降几十倍，但是`ReetrantLock`的性能能维持常态；



## 48.`Java`中用到的线程调度

一般线程调度模式分为两种——抢占式调度和协同式调度。

抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。

协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。




## 49.`synchronized `的原理是什么

`Java `虚拟机中的同步(`Synchronization`)基于进入和退出管程(`Monitor`)对象实现， 无论是显式同步(有明确的` monitorenter` 和 `monitorexit `指令,即同步代码块)还是隐式同步都是如此。



## 50.什么场景下可以使用 `volatile `替换 `synchronized`

只需要保证共享资源的可见性的时候可以使用`volatile`替代，`synchronized`保证可操作的原子性一致性和可见性。` volatile`适用于新值不依赖于就值的情形。



## 51.锁

乐观锁，每次操作时不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。可以使用`volatile+CAS`原语实现

悲观锁是会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。可以使用`synchronize`的以及`Lock`。

偏向锁：当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程`ID`，以后该线程在进入和退出同步块时不需要进行`CAS`操作来加锁和解锁，只需简单地测试一下锁对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。

轻量级锁：先在当前线程的栈桢中创建用于存储锁记录的空间，并将锁对象头中的`Mark Word`复制到锁记录中。然后线程尝试使用`CAS`将锁对象头中的`Mark Word`替换为指向锁记录（在线程栈帧中）的指针。

可重入锁：广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者`class`），这样的锁就叫做可重入锁。`ReentrantLock`和`synchronized`都是可重入锁。

不可重入锁：相对于可重入锁，它计算时同一线程也不能掉队调用已获得的锁，除非使用`unlock`进行释放。


## 52.死锁与活锁的区别，死锁与饥饿的区别

死锁：线程1运行需要资源`A、B`，此时占用着`A`，需要拿到`B`。而线程2运行也需要资源`A、B`，此时占用着`B`，需要拿到`A`。于是线程1等待线程2释放`B`，而线程2等待线程1释放`A`，而两个线程都需要拿到所需资源才能运行，之后才能释放资源，这样就导致了死锁。死锁是一种静态的，比如此时我停止线程1，线程2就可以执行了，死锁发生时谁都不能运行，`CPU`占用率为0。

活锁：就好比一条路上两个人迎面走来，撞在了一块，一个向右靠，另一个想法一样，于是向左靠，这样就又撞在了一起，这就是一种活锁，这是一个动态的，此时会导致`CPU`占用升高，而且很难查找。

饥饿：线程1运行需要资源`A、B`，此时占用着`A`，需要拿到`B`。而线程2运行也需要资源`A、B`，此时占用着`B`，需要拿到`A`。此时两个线程都发现了这点，于是两个线程都将自己占用的资源释放掉，都想在让另一个线程来执行，然后再去获取资源，此时可能线程1拿到了`B`，而线程2拿到了`A`，就这样往复。



## 53.如何实现分布式锁

方案一：数据库乐观锁，数据版本(`version`)
方案二：基于`Redis`的分布式锁
方案三：基于`Zookeeper`的分布式锁，利用节点名称的唯一性来实现独占锁



## 54.伪共享

假设不同的共享数据（相邻地址的区域）存入同一缓存行，从处理的角度看，某个数据改变都将导致同一缓存行中的其它数据无效。这种场景叫做伪共享。

## 55.读写锁`ReentrantLock`

读写锁分为读锁和写锁，多个读锁之间是不需要互斥的(读操作不会改变数据，如果上了锁，反而会影响效率)，写锁和写锁之间需要互斥，也就是说，如果只是读数据，就可以多个线程同时读，但是如果你要写数据，就必须互斥，使得同一时刻只有一个线程在操作。

## 56.`Executor，Executors，ExecutorService`

`Executor`

* 1、并发编程的一种编程方式是把任务拆分为一系列的小任务，即`Runnable`，然后将这些任务提交给一个`Executor`执行，`Executor.execute(Runnalbe) `。`Executor`在执行时使用其内部的线程池来完成操作。
    `Executor`的子接口有：`ExecutorService,ScheduledExecutorService`,已知实现类：`AbstractExecutorService,ScheduledThreadPoolExecutor,ThreadPoolExecutor`。
* 2、`Executor`属于`public`类型的接口。可以用于提交，管理或者执行`Runnable`任务。实现`Executor`接口的`class`还可以控制`Runnable`任务执行线程的具体细节。包括线程使用的细节、调度等。

`Executors`

`Executors`类： 主要用于提供线程池相关的操作`Executors`类： 主要用于提供线程池相关的操作

`ExecutorService`

`ExecutorService`可以理解为程序员提供了一堆操作`Executor`的`API`。



## 57.`Error `和 `Exception`有什么区别

`Java`标准库内建了一些通用的异常，这些类以`Throwable`为顶层父类。`Throwable`又派生出`Error`类和`Exception`类。

* 错误：`Error`类以及他的子类的实例，代表了`JVM`本身的错误。错误不能被程序员通过代码处理，`Error`很少出现。因此，程序员应该关注`Exception`为父类的分支下的各种异常类。
* 异常：`Exception`以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被`Java`异常处理机制使用，是异常处理的核心。
  * 非检查异常（`unckecked exception`）：`Error `和 `RuntimeException` 以及他们的子类。
  * 检查异常（checked exception）：除了`Error `和 `RuntimeException`的其它异常。


## 58.`throw` 和 `throws `有什么区别

`throws`语句

`throws`总是出现在一个函数头中，用来标明该成员函数可能抛出的各种异常。 如果你想明确地抛出一个`RuntimeException`，你必须用`throws`语句来声明它的类型。  

`throw`语句 
`throw`总是出现在函数体中，用来抛出一个异常。程序会在`throw`语句后立即终止，它后面的语句执行不到，然后在包含它的所有`try`块中（可能在上层调用函数中）从里向外寻找含有与其匹配的`catch`子句的`try`块。



## 59. springboot启动流程

每个`SpringBoot`程序都有一个主入口，也就是`main`方法，`main`里面调用`SpringApplication.run()`启动整个程序，该方法所在类需要使用`@SpringBootApplication`注解。

`@SpringBootApplication`包括三个注解，功能如下：

* `@EnableAutoConfiguration：SpringBoot`根据应用所声明的依赖来对`Spring`框架进行自动配置
* `@SpringBootConfiguration`(内部为`@Configuration`)：被标注的类等于在`spring`的`XML`配置文件中(`applicationContext.xml`)，装配所有`bean`事务，提供了一个`spring`的上下文环境
* `@ComponentScan`：组件扫描，可自动发现和装配`Bean`，默认扫描`SpringApplication`的`run`方法里的`Booter.class`所在的包路径下文件，所以最好将该启动类放到根包路径下

1、`run`方法中去创建了一个`SpringApplication`实例，在该构造方法内，我们可以发现其调用了一个初始化的`initialize`方法，主要是为`SpringApplication`对象赋一些初值。

2、创建了应用的监听器`SpringApplicationRunListeners`并开始监听

3、加载`SpringBoot`配置环境(`ConfigurableEnvironment`)，如果是通过web容器发布，会加载`StandardEnvironment`，其最终也是继承了`ConfigurableEnvironment`

4、配置环境(`Environment`)加入到监听器对象中(`SpringApplicationRunListeners`)

5、创建`run`方法的返回对象：`ConfigurableApplicationContext`(应用配置上下文)，创建方法会先获取显式设置的应用上下文(`applicationContextClass`)，如果不存在，再加载默认的环境配置（通过是否是`web environment`判断），默认选择`AnnotationConfigApplicationContext`注解上下文（通过扫描所有注解类来加载`bean`），最后通过`BeanUtils`实例化上下文对象，并返回。

`ConfigurableApplicationContext`主要看其继承的两个方向：

* `LifeCycle`：生命周期类，定义了`start`启动、`stop`结束、`isRunning`是否运行中等生命周期空值方法

* `ApplicationContext`：应用上下文类，其主要继承了`beanFactory`(`bean`的工厂类)，此对象的初始化就是`spring`的内容了

## 60. 实现equals方法

```java
package win.iot4yj.leetcode;

import java.util.Objects;

public class Person {
	private String username;
	private Integer age;

	//getter、setter

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Person person = (Person) o;
		return Objects.equals(username, person.username) &&
				Objects.equals(age, person.age);
	}

	@Override
	public int hashCode() {
		return Objects.hash(username, age);
	}
}

```

## 61. 单例模式

基本的单例模式这里不说了，这里主要看双重锁检查实现单例

参考：`http://www.importnew.com/12196.html`

